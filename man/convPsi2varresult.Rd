% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/convPsi2varresult.R
\name{convPsi2varresult}
\alias{convPsi2varresult}
\title{Convert format for VAR coefficients from Psi to varresult}
\usage{
convPsi2varresult(Psi, Y, X, lambda0, type = c("const", "trend", "both",
  "none"), ybar = NULL, xbar = NULL, Q_values = NULL, callstr = "")
}
\arguments{
\item{Psi}{An M-by-K matrix of VAR coefficients}

\item{Y}{An N-by-K data matrix of dependent variables}

\item{X}{An N-by-M data matrix of regressors}

\item{lambda0}{A rescaled shrinkage intensity parameter, based on which the
effective number of parameters is computed by Trace(X(X'X+lambda0*I)^{-1}X')}

\item{type}{Type of deterministic variables in the VAR estimation problem.
Either of "const", "trend", "both", or "none".}

\item{ybar, xbar}{NULL if Y and X are not centered. Mean vectors if Y and X
had been centered. If Y and X had been centered (ybar and xbar are not NULL)
and type is "const" or "both", then the coefficients for the constant term
is computed and concatenated to the coefficients.}

\item{Q_values}{Nonnegative weight vector of length N. Default is NULL.
Take weights on rows (samples) of Y and X by sqrt(Q).}

\item{callstr}{The call to VARshrink().}
}
\value{
A list object with objects of class c("shrinklm", "lm").
Each "shrinklm" object has components: coefficients, residuals, fitted.values,
rank, df.residual, lambda0, call, terms, svd
}
\description{
Convert a matrix of VAR coefficients estimated by a shrinkage method
into a list of "shrinklm" object. The class "shrinklm" inherits the class
"lm".
}
\details{
Consider VAR(p) model: y_t = A_1 y_{t-1} + ... + A_p y_{t-p} + C d_t + e_t.
It can be written in the matrix form: Y = X %*% Psi + E,
where Psi is a concatenated M-by-K matrix, Psi = (A_1, ..., A_p, C)^T.

The function converts Psi into a list of "shrinklm" objects which
inherited the class "lm". Consider the multiple linear regression form
of a VAR(p) model: y_j = X %*% psi_j + e_j, j=1,...,K.
Each "shrinklm" object contains the length-M vector psi_j as coefficients.

Considering that each coefficient vector psi_j is estimated by a
shrinkage method, the effective number of parameters, k_eff, is
computed as: k_eff = Trace(X %*% (X^T %*% X + lambda0 * I)^{-1} %*% X').
Then, the degree of freedom of residuals is computed as: df.residual =
N - k_eff, where N is the number of rows of data matrices Y and X.
}
